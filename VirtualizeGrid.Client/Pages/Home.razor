@page "/"
@using Grpc.Net.Client
@using VirtualizedGrid.Protos
@inject GrpcChannel Channel
@inject LocalDatabaseService DatabaseService

<h3>Parts List</h3>
<style>
    .content-container {
        padding-bottom: 80px; /* Space for the footer */
    }

    .fixed-footer {
        position: fixed;
        bottom: 0;
        width: 100%;
        background-color: #f8f8f8;
        padding: 10px;
        text-align: center;
        font-weight: bold;
        border-top: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .progress-bar {
        width: 100%;
        background-color: #e0e0e0;
        height: 20px;
        border-radius: 5px;
        margin-top: 5px;
    }

    .progress {
        background-color: #4caf50;
        height: 100%;
        border-radius: 5px;
        text-align: center;
        color: white;
    }

    .footer-details p {
        margin: 5px 0;
        font-size: 14px;
    }

    .saving-indicator {
        color: #f39c12;
    }

</style>

<Virtualize Items="@parts" Context="part" ItemSize="50">
    <div style="padding: 5px; border-bottom: 1px solid #ccc;">
        <strong>@part.Name</strong> - @part.Status <br />
        Created on: @part.CreationDate.ToString("yyyy-MM-dd")
    </div>
</Virtualize>

<div class="fixed-footer">
    <div class="progress-bar">
        <div class="progress" style="width: @ProgressPercentage%;">@ProgressPercentage% loaded</div>
    </div>
    <div class="footer-details">
        <p>Progress: @ProgressPercentage% | Items Fetched: @ItemsFetched | Data Size: @DataSize MB | Time: @TimeSpentFetching seconds</p>
        @if (IsSavingToCache)
        {
            <p class="saving-indicator">Saving to cache...</p>
        }
    </div>
</div>

@code {
    private List<PartDto> parts = new();
    private int ProgressPercentage = 0;
    private int ItemsFetched = 0;
    private int TotalItems = 100_000; // Default or placeholder value
    private double DataSize = 0;
    private double TimeSpentFetching = 0;
    private bool IsSavingToCache = false;

    protected override async Task OnInitializedAsync()
    {
        // Load data from cache first
        parts = await DatabaseService.LoadCachedPartsDataAsync();
        ItemsFetched = parts.Count;
        DataSize = CalculateDataSize(parts);
        StateHasChanged();

        var client = new PartService.PartServiceClient(Channel);
        var totalCountResponse = await client.GetPartsCountAsync(new Google.Protobuf.WellKnownTypes.Empty());
        TotalItems = totalCountResponse.TotalCount;

        if (ItemsFetched < TotalItems)
        {
            await FetchAndCacheDataFromServer(client);
        }
    }

    private async Task FetchAndCacheDataFromServer(PartService.PartServiceClient client)
    {
        var request = new PartsRequest { ChunkSize = 20_000 };
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        using var call = client.GetParts(request);
        List<PartDto> newParts = new();

        try
        {
            while (await call.ResponseStream.MoveNext(CancellationToken.None))
            {
                var batch = call.ResponseStream.Current;
                foreach (var part in batch.Parts)
                {
                    var partDto = new PartDto
                        {
                            Id = Guid.Parse(part.Id),
                            Name = part.Name,
                            CreationDate = DateTimeOffset.Parse(part.CreationDate),
                            Status = (PartStatus)part.Status
                        };
                    parts.Add(partDto);
                    newParts.Add(partDto);
                    ItemsFetched++;
                }

                ProgressPercentage = (ItemsFetched * 100) / TotalItems;
                DataSize = CalculateDataSize(parts);
                StateHasChanged();
            }

            // Indicate that caching is in progress
            IsSavingToCache = true;
            StateHasChanged();

            // Cache data in IndexedDB
            await DatabaseService.CachePartsDataAsync(newParts);

            // Indicate that caching has completed
            IsSavingToCache = false;
        }
        catch (Exception ex)
        {
            // Handle exceptions
        }
        finally
        {
            stopwatch.Stop();
            TimeSpentFetching = stopwatch.Elapsed.TotalSeconds;
            StateHasChanged(); // Final UI update after fetching completes
        }
    }

    private double CalculateDataSize(List<PartDto> data)
    {
        int sizePerItem = 16 + (36 + 8 + 4);
        return (data.Count * sizePerItem) / (1024.0 * 1024.0);
    }

    public class PartDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public DateTimeOffset CreationDate { get; set; }
        public PartStatus Status { get; set; }
    }

    public enum PartStatus
    {
        Available,
        OutOfStock,
        Discontinued,
        BackOrder
    }
}
